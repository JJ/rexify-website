% layout 'default';
% title 'Rex::Commands::File - Transparent File Manipulation';

% content_for header => begin
      <meta name="description" content="With this module you can manipulate files.">
      <meta name="keywords" content="Rex, API, Documentation">
% end 


<!-- INDEX BEGIN -->
<div name="index">
<h1>TABLE OF CONTENTS</h1>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
</ul>


</div>
<!-- INDEX END -->

<p>
</p>
<h2>NAME</h2>
<p>Rex::Commands::File - Transparent File Manipulation</p>
<p>
</p>

<h2>DESCRIPTION</h2>
<p>With this module you can manipulate files.</p>
<p>
</p>

<h2>SYNOPSIS</h2>
<pre><code class="perl">
 task &quot;read-passwd&quot;, &quot;server01&quot;, sub {
    my $fh = file_read &quot;/etc/passwd&quot;;
    for my $line = ($fh-&gt;read_all) {
       print $line;
    }
    $fh-&gt;close;
 };</code></pre>
<pre><code class="perl">
 task &quot;read-passwd2&quot;, &quot;server01&quot;, sub {
    say cat &quot;/etc/passwd&quot;;
 };
 
 
 task &quot;write-passwd&quot;, &quot;server01&quot;, sub {
    my $fh = file_write &quot;/etc/passwd&quot;;
    $fh-&gt;write(&quot;root:*:0:0:root user:/root:/bin/sh\n&quot;);
    $fh-&gt;close;
 };
    
 delete_lines_matching &quot;/var/log/auth.log&quot;, matching =&gt; &quot;root&quot;;
 delete_lines_matching &quot;/var/log/auth.log&quot;, matching =&gt; qr{Failed};
 delete_lines_matching &quot;/var/log/auth.log&quot;, 
                        matching =&gt; &quot;root&quot;, qr{Failed}, &quot;nobody&quot;;
    
 file &quot;/path/on/the/remote/machine&quot;,
    source =&gt; &quot;/path/on/local/machine&quot;;
    
 file &quot;/path/on/the/remote/machine&quot;,
    content =&gt; &quot;foo bar&quot;;
    
 file &quot;/path/on/the/remote/machine&quot;,
    source =&gt; &quot;/path/on/local/machine&quot;,
    owner  =&gt; &quot;root&quot;,
    group  =&gt; &quot;root&quot;,
    mode   =&gt; 400,
    on_change =&gt; sub { say &quot;File was changed.&quot;; };
 
=head1 EXPORTED FUNCTIONS</code></pre>
<ul>
<li><strong>template($file, @params)</strong></li>


<p>Parse a template and return the content.</p>
<pre><code class="perl">
 my $content = template(&quot;/files/templates/vhosts.tpl&quot;, 
                     name =&gt; &quot;test.lan&quot;,
                     webmaster =&gt; 'webmaster@test.lan');</code></pre>

<li><strong>file($file_name, %options)</strong></li>


<p>This function is the successor of <em>install file</em>. Please use this function to upload files to you server.</p>
<pre><code class="perl">
 task &quot;prepare&quot;, &quot;server1&quot;, &quot;server2&quot;, sub {
    file &quot;/file/on/remote/machine&quot;,
       source =&gt; &quot;/file/on/local/machine&quot;;
       
    file &quot;/etc/hosts&quot;,
       content =&gt; template(&quot;templates/etc/hosts.tpl&quot;),
       owner   =&gt; &quot;user&quot;,
       group   =&gt; &quot;group&quot;,
       mode    =&gt; 700,
       on_change =&gt; sub { say &quot;Something was changed.&quot; };
        
    file &quot;/etc/motd&quot;,
       content =&gt; `fortune`;
      
    file &quot;/etc/httpd/conf/httpd.conf&quot;,
       source =&gt; &quot;/files/etc/httpd/conf/httpd.conf&quot;,
       on_change =&gt; sub { service httpd =&gt; &quot;restart&quot;; };
 };</code></pre>
<p>If <em>source</em> is relative it will search from the location of your <em>Rexfile</em> or the <em>.pm</em> file if you use Perl packages.</p>

<li><strong>file_write($file_name)</strong></li>


<p>This function opens a file for writing (it will truncate the file if it already exists). It returns a Rex::FS::File object on success.</p>
<p>On failure it will die.</p>
<pre><code class="perl">
 my $fh;
 eval {
    $fh = file_write(&quot;/etc/groups&quot;);
 };
 
 # catch an error
 if($@) {
    print &quot;An error occured. $@.\n&quot;;
 }
 
 # work with the filehandle
 $fh-&gt;write(&quot;...&quot;);
 $fh-&gt;close;</code></pre>

<li><strong>file_append($file_name)</strong></li>

<li><strong>file_read($file_name)</strong></li>


<p>This function opens a file for reading. It returns a Rex::FS::File object on success.</p>
<p>On failure it will die.</p>
<pre><code class="perl">
 my $fh;
 eval {
    $fh = read(&quot;/etc/groups&quot;);
 };
 
 # catch an error
 if($@) {
    print &quot;An error occured. $@.\n&quot;;
 }
 
 # work with the filehandle
 my $content = $fh-&gt;read_all;
 $fh-&gt;close;</code></pre>

<li><strong>cat($file_name)</strong></li>


<p>This function returns the complete content of $file_name as a string.</p>
<pre><code class="perl">
 print cat &quot;/etc/passwd&quot;;</code></pre>

<li><strong>delete_lines_matching($file, $regexp)</strong></li>


<p>Delete lines that match $regexp in $file.</p>
<pre><code class="perl">
 task &quot;clean-logs&quot;, sub {
     delete_lines_matching &quot;/var/log/auth.log&quot; =&gt; &quot;root&quot;;
 };</code></pre>

<li><strong>delete_lines_according_to($search, $file, @options)</strong></li>


<p>This is the successor of the <a href="#delete_lines_matching">delete_lines_matching()</a> function. This function also allows the usage of an on_change hook.</p>
<p>It will search for $search in $file and remove the found lines. If on_change hook is present it will execute this if the file was changed.</p>
<pre><code class="perl">
 task &quot;cleanup&quot;, &quot;server1&quot;, sub {
    delete_lines_according_to qr{^foo:}, &quot;/etc/passwd&quot;,
      on_change =&gt; sub {
         say &quot;removed user foo.&quot;;
      };
 };</code></pre>

<li><strong>append_if_no_such_line($file, $new_line, @regexp)</strong></li>


<p>Append $new_line to $file if none in @regexp is found. If no regexp is
supplied, the line is appended unless there is already an identical line
in $file.</p>
<pre><code class="perl">
 task &quot;add-group&quot;, sub {
    append_if_no_such_line &quot;/etc/groups&quot;, &quot;mygroup:*:100:myuser1,myuser2&quot;, on_change =&gt; sub { service sshd =&gt; &quot;restart&quot;; };
 };</code></pre>
<p>Since 0.42 you can use named parameters as well</p>
<pre><code class="perl">
 task &quot;add-group&quot;, sub {
    append_if_no_such_line &quot;/etc/groups&quot;,
       line   =&gt; &quot;mygroup:*:100:myuser1,myuser2&quot;,
       regexp =&gt; qr{^mygroup},
       on_change =&gt; sub {
                       say &quot;file was changed, do something.&quot;;
                    };
          
    append_if_no_such_line &quot;/etc/groups&quot;,
       line   =&gt; &quot;mygroup:*:100:myuser1,myuser2&quot;,
       regexp =&gt; [qr{^mygroup:}, qr{^ourgroup:}]; # this is an OR
 };
=cut
sub append_if_no_such_line {
   my $file = shift;
   my ($new_line, @m);</code></pre>
<pre><code class="perl">
   # check if parameters are in key =&gt; value format
   my ($option, $on_change);</code></pre>
<pre><code class="perl">
   eval {
      no warnings;
      $option = { @_ };
      # if there is no line parameter, it is the old parameter format
      # so go dieing
      if(! exists $option-&gt;{line}) {
         die;
      }
      $new_line = $option-&gt;{line};
      if(exists $option-&gt;{regexp} &amp;&amp; ref $option-&gt;{regexp} eq &quot;Regexp&quot;) {
         @m = ($option-&gt;{regexp});
      }
      elsif(ref $option-&gt;{regexp} eq &quot;ARRAY&quot;) {
         @m = @{ $option-&gt;{regexp} };
      }
      $on_change = $option-&gt;{on_change} || undef;
      1;
   } or do {
      ($new_line, @m) = @_;
      # check if something in @m (the regexpes) is named on_change
      for (my $i = 0; $i&lt;$#m; $i++ ) {
         if ( $m[$i] eq &quot;on_change&quot; &amp;&amp; ref($m[$i+1]) eq &quot;CODE&quot; ) {
            $on_change = $m[$i+1];
            splice(@m,$i,2);
            last;
         }
      }
   };</code></pre>
<pre><code class="perl">
   my $fs = Rex::Interface::Fs-&gt;create;</code></pre>
<pre><code class="perl">
   if ( !@m ) {
      push @m, qr{^\Q$new_line\E$}m;
   }</code></pre>
<pre><code class="perl">
   # i don't like this next line...
   # normalizing regexp serialization for older perl versions
   for (@m) {
      $_ = _normalize_regex($_);
   }</code></pre>
<pre><code class="perl">
   my $template = template(get_file_path(&quot;templates/append_if_no_such_line.tpl.pl&quot;),
      line =&gt; $new_line,
      regex =&gt; \@m,
      file =&gt; $file,
      __no_sys_info__ =&gt; 1);</code></pre>
<pre><code class="perl">
   my $old_md5;
   if ($on_change) {
      $old_md5 = md5($file);
   }</code></pre>
<pre><code class="perl">
   my $f = upload_and_run $template, with =&gt; &quot;perl&quot;;</code></pre>
<pre><code class="perl">
   my $ret = $?;
   if ($ret==1) {
      die(&quot;Can't open $file for reading&quot;);
   }
   elsif ($ret==2) {
      die(&quot;Can't open temp file for writing&quot;);
   }
   elsif ($ret==3) {
      die(&quot;Can't open $file for writing&quot;);
   }</code></pre>
<pre><code class="perl">
   if ($on_change) {
      my $new_md5 = md5($file);
      unless($old_md5 &amp;&amp; $new_md5 &amp;&amp; $old_md5 eq $new_md5) {
         $old_md5 ||= &quot;&quot;;
         $new_md5 ||= &quot;&quot;;</code></pre>
<pre><code class="perl">
         Rex::Logger::debug(&quot;File $file has been changed... Running on_change&quot;);
         Rex::Logger::debug(&quot;old: $old_md5&quot;);
         Rex::Logger::debug(&quot;new: $new_md5&quot;);
         &amp;$on_change($file);
      }
   }</code></pre>
<p>#   my $content = cat ($file);
#   for my $match (@m) {
#      if ( $content =~ /$match/m ) {
#         return 0;
#      }
#   }</p>
<p>#   $content .= &quot;$new_line\n&quot;;
#   my $fh = file_write $file;
#   unless($fh) {
#      die(&quot;Can't open $file for writing&quot;);
#   }
#   $fh-&gt;write($content);
#   $fh-&gt;close;</p>
<p>#   &amp;$on_change() if defined $on_change;
}</p>

<li><strong>extract($file [, %options])</strong></li>


<p>This function extracts a file. Supported formats are .box, .tar, .tar.gz, .tgz, .tar.Z, .tar.bz2, .tbz2, .zip, .gz, .bz2, .war, .jar.</p>
<pre><code class="perl">
 task prepare =&gt; sub {
    extract &quot;/tmp/myfile.tar.gz&quot;,
      owner =&gt; &quot;root&quot;,
      group =&gt; &quot;root&quot;,
      to    =&gt; &quot;/etc&quot;;</code></pre>
<pre><code class="perl">
    extract &quot;/tmp/foo.tgz&quot;,
      type =&gt; &quot;tgz&quot;,
      mode =&gt; &quot;g+rwX&quot;;
 };
 
Can use the type=&gt; option if the file suffix has been changed. (types are tar, tgz, tbz, zip, gz, bz2)</code></pre>

<li><strong>sed($search, $replace, $file)</strong></li>


<p>Search some string in a file and replace it.</p>
<pre><code class="perl">
 task sar =&gt; sub {
    sed qr{search}, &quot;replace&quot;, &quot;/var/log/auth.log&quot;;
 };</code></pre>

</ul>




